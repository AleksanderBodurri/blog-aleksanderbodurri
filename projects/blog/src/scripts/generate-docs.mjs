import { writeFileSync, readdirSync, readFileSync } from "fs";
import { format } from "prettier";
import { remark } from "remark";
import remarkHtml from "remark-html";
import remarkPrism from "remark-prism";

const generatedRoutesPath = "./projects/blog/src/app/generated-routes.ts";
const markdownPath = "./projects/blog/src/assets/md";
const generatedModulePath = "./projects/blog/src/app/generated-route-modules";
const postMetaDataPath =
  "./projects/blog/src/app/routes/posts/generated-post-metadata.ts";
const componentsForGeneratedRoutesPath =
  "./projects/blog/src/app/components-for-generated-routes";

let pages = [];

let componentSelectors = {};
const componentPromises = readdirSync(componentsForGeneratedRoutesPath).map(
  async (file) => {
    componentSelectors[
      file
    ] = `${componentsForGeneratedRoutesPath}/${file}/${file}.component.ts`;
  }
);
await Promise.all(componentPromises);
console.log(componentSelectors);

const pagePromises = readdirSync(markdownPath).map(async (file) => {
  const path = `${markdownPath}/${file}`;
  const contentFiles = readdirSync(path);
  const codeblocks = contentFiles
    .filter((name) => name !== "metadata.json")
    .sort();

  const constructComponent = async (metadata) => {
    let content = readFileSync(`${path}/page.md`);

    let output = String(
      await remark()
        .use(remarkPrism)
        .use(remarkHtml, { sanitize: false })
        .process(content)
    );
    output = output.replace(/\$/g, "\\$");
    output = output.replace(/`/g, "\\`");
    output = output.replace(/([{}])/g, "{{ '$1' }}");
    output = format(output, { semi: false, parser: "html" });

    const description = metadata["description"];
    const tags = ["blog", "post", ...(metadata?.["tags"] ?? [])];
    const title = metadata["title"];

    const styles = readFileSync("./projects/blog/src/scripts/post-styles.scss");

    return `
@Component({
  selector: 'blog-${file}',
  template: \`
${output}
  \`,
  styles: [\`
    ${styles}
\`]
})
export class ${toUpperCamelCase(file)}Component implements OnInit, OnDestroy {
  constructor(
    @Inject(PLATFORM_ID) public platformId: Object,
    private meta: Meta
  ){}

  ngOnInit(): void {
    this.meta.addTag({ property: 'og:title', content: '${title}' });
    this.meta.addTag({ property: 'og:type', content: 'article' });
    this.meta.addTag({ property: 'og:url', content: 'https://aleksanderbodurri-eefbe.web.app/posts/${file}' });
    this.meta.addTag({ property: 'og:image', content: 'http://aleksanderbodurri-eefbe.web.app/assets/me.png' });
    this.meta.addTag({ property: 'og:image:secure_url', content: 'https://aleksanderbodurri-eefbe.web.app/assets/me.png' });

    if (${description.length > 0}) {
      this.meta.addTag({ name: 'description', content: '${description}' });
    }

    if (${tags.length > 0}) {
      this.meta.addTag({ name: 'keywords', content: '${tags.join(",")}' });
    }
  }

  ngOnDestroy(): void {
    this.meta.removeTag('property="oh:title"');
    this.meta.removeTag('property="oh:type"');
    this.meta.removeTag('property="oh:url"');
    this.meta.removeTag('property="oh:image"');
    this.meta.removeTag('property="oh:image:secure_url"');

    if (${metadata["description"].length > 0}) {
      this.meta.removeTag('name=description');
    }
    
    if (${metadata["tags"].length > 0}) {
      this.meta.removeTag('name=keywords');
    }
  }
}
    `;
  };

  const constructModuleAndComponent = async (name, metadata) => {
    const component = await constructComponent(metadata);

    const importExpressions = Object.keys(componentSelectors).map(
      (selector) => {
        return `import { ${toUpperCamelCase(
          selector
        )}Component } from '../components-for-generated-routes/${selector}/${selector}.component'`;
      }
    );
    const cmpImportExpressions = Object.keys(componentSelectors).map(
      (selector) => {
        return `${toUpperCamelCase(selector)}Component`;
      }
    );

    return `// THIS FILE WAS GENERATED BY TOOLING. DO NOT EDIT THIS FILE DIRECTLY.

import { Component, NgModule, Inject, PLATFORM_ID, OnInit, OnDestroy } from "@angular/core";
import { RouterModule } from "@angular/router";
import { CommonModule } from "@angular/common";
import { Meta } from '@angular/platform-browser';

${importExpressions.join(";\n")}

${component}

@NgModule({
  imports: [
    CommonModule,
    RouterModule.forChild([
      {
        path: '',
        pathMatch: 'full',
        component: ${toUpperCamelCase(name)}Component,
      },
    ]),
    ${cmpImportExpressions.join(",\n    ")}

  ],
  declarations: [
    ${toUpperCamelCase(name)}Component,
  ],
  bootstrap: [],
})
export class LazyModule {}
    `;
  };

  const constructRoute = (slug, title) => {
    return `{
      path: 'posts/${slug}',
      title: '${title} | Aleksander Bodurri | Blog',
      loadChildren: () => import('./generated-route-modules/${slug}.module').then((m) => m.LazyModule)
    }`;
  };

  const metadata = JSON.parse(readFileSync(`${path}/metadata.json`));
  const lazyModule = await constructModuleAndComponent(file, metadata);
  const route = constructRoute(file, metadata["title"]);
  metadata["slug"] = file;
  metadata["sectionNames"] = contentFiles;
  metadata["summary"] = "" + readFileSync(`${path}/summary.md`);

  let summaryOutput = String(
    await remark()
      .use(remarkPrism)
      .use(remarkHtml, { sanitize: false })
      .process(metadata["summary"])
  );
  summaryOutput = summaryOutput.replace(/\$/g, "\\$");
  summaryOutput = summaryOutput.replace(/`/g, "\\`");
  summaryOutput = summaryOutput.replace(/([{}])/g, "{{ '$1' }}");
  summaryOutput = format(summaryOutput, { semi: false, parser: "html" });
  metadata["summary"] = summaryOutput;
  metadata["codeblocks"] = {};

  await Promise.all(
    codeblocks.map(async (codeblock) => {
      let codeblockOutput = "" + readFileSync(`${path}/${codeblock}`);
      codeblockOutput = String(
        await remark()
          .use(remarkPrism)
          .use(remarkHtml, { sanitize: false })
          .process(codeblockOutput)
      );
      codeblockOutput = format(codeblockOutput, {
        semi: false,
        parser: "html",
      });
      metadata["codeblocks"][codeblock] = codeblockOutput;
    })
  );

  pages.push({
    file,
    route,
    lazyModule,
    metadata,
  });
});

await Promise.all(pagePromises);

pages = pages.sort(
  (a, b) => new Date(b.metadata.date) - new Date(a.metadata.date)
);

let generatedRoutes = ``;
generatedRoutes +=
  "// THIS FILE WAS GENERATED BY TOOLING. DO NOT EDIT THIS FILE DIRECTLY.\n";
generatedRoutes += 'import { Routes } from "@angular/router";\n\n';

generatedRoutes += `export const GENERATED_ROUTES: Routes = [${pages
  .map((page) => page.route)
  .join(",\n")}];`;
writeFileSync(
  generatedRoutesPath,
  format(generatedRoutes, { semi: false, parser: "babel" })
);

pages.forEach((page) => {
  writeFileSync(
    `${generatedModulePath}/${page.file}.module.ts`,
    page.lazyModule
  );
});

let generatedPostMetaData = ``;
generatedPostMetaData += `// THIS FILE WAS GENERATED BY TOOLING. DO NOT EDIT THIS FILE DIRECTLY.\n`;
generatedPostMetaData += `import { PostMetaData } from "./post-metadata";\n\n`;
generatedPostMetaData += `export const postMetaData: PostMetaData[] = [${pages
  .map((page) => JSON.stringify(page.metadata))
  .join(",\n")}];`;
writeFileSync(
  postMetaDataPath,
  format(generatedPostMetaData, { semi: false, parser: "babel" })
);

function toUpperCamelCase(string) {
  return string
    .toLowerCase()
    .split("-")
    .map((it) => it.charAt(0).toUpperCase() + it.substr(1))
    .join("");
}
